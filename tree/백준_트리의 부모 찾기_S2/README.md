# 문제

백준 사이트의 **S2** 난이도 11725번 문제인 **트리의 부모 찾기**이다.

Main.java는 DFS, Main2.java는 BFS를 사용하였다.
탐색 방식 외 로직은 완전히 동일하며 (최대 `99999`번 재귀 또는 반복 수행), BFS가 시간 및 메모리 면에서 우세할 것으로 예상했으나 실제 차이는 거의 없었다. 

[문제보기](https://www.acmicpc.net/problem/11725)

## 요약
- 2차원 ArrayList 선언 방식 보자
- 2차원 벡터 대신 2차원 ArrayList 쓰자 (ArrayList 배열 말고)

##   접근 방식

> Main1과 Main2의 로직이 같으므로 따로 구별하지 않고 서술함

트리 문제이지만, 트리를 완전히 구현하는 문제가 아니라 부모만 구하면 되는 문제였다.
입력은 `(노드 번호, 노드 번호)`로 `노드의 개수 N-1` 만큼의 노드간 연결 관계가 주어지며, 어느 쪽이 부모인지는 알 수 없으나 반드시 1번 노드가 루트이다.

　즉 1번 또는 1번에 속한 노드와 직접적으로 연결 관계가 나타나기 전까진 주어진 연결 관계 내에서 어떤 노드가 부모인지, 자식인지 알 수 없는 상황이다. 따라서 주어진 연결 관계를 따로 저장할 필요가 있었다.

　C++이었다면 `Map` 또는 `vector`으로 아주 간단하게 해결했을 것 같지만, 자바의 맵은 일일이 key가 존재하는지 체크해주어야 하며, put과 set으로 접근 방식이 나뉘어 있으므로 불편하여 쓰지 않았다. (메모리에 대한 걱정도 있었다.)
　남은 건 vector인데, 자바에서는 vector대신 `ArrayList`를 권장하므로 이를 사용하였다. 다만 실제 사용시에 불편한 점이 몇 가지 있었다.
 
> 1. ArrayList 선언 시 Generic 타입이 reference 타입이라면 자동 초기화가 되지 않는다.
> 2. ArrayList 배열 선언 시 타입 안전성경고 발생

1번 문제 때문에 `vector`와 다르게 일일이 반복문을 수행하여 `ArrayList`를 `add` 해주어야 했다. 2번 문제는 아래에 코드를 보자.

~~~java
// ArrayList<Integer>[] list = new ArrayList[N]; // Type safety 경고 발생
ArrayList<ArrayLsit<Integer> list = new ArrayLIst<>(); // 이것을 사용함
~~~
사실 PS 시에 타입 안정성 때문에 런타임 예외가 발생할 일은 없겠지만, 그래도 찜찜하여 ArrayList를 원소로 하는 ArrayList를 선언했다.  


## 이 문제를 기록하는 이유
2차원 벡터를 대신할 자료구조를 찾는 데, 또 특히 ArrayList 배열 선언 방식을 찾는 데에 시간이 꽤 소요되었다.

따라서 2차원 벡터를 대신할 자료구조인 2차원 ArrayList와 선언 방식을 기억하기 위해 문제를 기록한다. 나중에 더 좋은 방법을 찾으면, 이 문제를 그 방법으로 풀어 메모리 및 소요 시간을 비교하면 좋을 것 같다는 생각도 든다.
