# 문제

백준 사이트의 **S1** 난이도 6808번 문제인 **도영이가 만든 맛있는 음식**이다.


[문제보기](https://www.acmicpc.net/problem/2961)

## 요약
- 비트 마스킹으로 부분 집합 접근 정리 (재귀 X)
```java
// 집합의 원소의 수 N개
for (int i = 1; i < (1 << N); i++) { // 공집합도 포함하고 싶다면 i=0으로. 0~N 대신 2의 제곱수를 사용하여 원소 개수의 범위도 지정할 수 있겠다.
	for (int j = 0; j < N; j++) {
		if ((i & (1<<j)) != 0) {
			// do something
		}
	}
}
```

##   접근 방식

평범한 부분집합 구하기 문제였다. 부분 집합만 구한다면 문제에서 요구하는 계산은 아무것도 아니다.
구하는 방식은 비트 마스킹을 사용했다.

```java
// 집합의 원소의 수 N개
for (int i = 1; i < (1 << N); i++) {
	for (int j = 0; j < N; j++) {
		if ((i & (1<<j)) != 0) {
			// do something
		}
	}
}
```
코드는 요약에 썼듯이 이러한데, 먼저 첫 번째 for문의 경우, 0001(32비트지만 뒤 4비트만 쓰겠음)부터 1111까지 다 보고 싶다는 것이다. 1 << N이 2^N이므로 대입해서 생각해보면 이해간다.

두 번째 for문은, 간단히 말해서 0부터 N-1번째 자리가 1인지 체크하는 것이다.
예를 들어 현재 i가 11, 즉 1011이라면, 0001 ,0010, 0100, 1000과 비교하게 되어 결국 1,3,4번 째 원소가 골라져 있다는 것을 알 게 된다. 이 후 1,3,4번 원소를 가지는 부분 집합을 대상으로 무언 가를 할 수 있을 것이다.



## 이 문제를 기록하는 이유
원래 C++ 에서는 next_permutation을 사용해서 부분집합도 구했던 것 같은데.. 이번에 비트 마스킹으로 구하는 방법을 알게되어 사용해보았다.

내가 유독 비트 연산에 약한 것 같아서, 비트 관련 문제 또는 개념이 나오면 전부 기록할 예정이다.